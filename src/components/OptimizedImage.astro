---
import { Image } from 'astro:assets';

interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  quality?: number;
  class?: string;
  loading?: 'lazy' | 'eager';
  sizes?: string;
  responsive?: boolean;
}

const {
  src,
  alt,
  width = 800,
  height = 600,
  quality = 80,
  class: className = '',
  loading = 'lazy',
  sizes = '(min-width: 1024px) 800px, (min-width: 768px) 600px, 100vw',
  responsive = true
} = Astro.props;

// Determina il percorso dell'immagine ottimizzata
const getOptimizedImagePath = (originalSrc: string, format: string) => {
  if (!originalSrc) return '';
  
  // Se l'immagine √® gi√† in uploads/, usa il percorso ottimizzato
  if (originalSrc.includes('/uploads/')) {
    // Estrai solo il nome del file dall'URL
    const urlParts = originalSrc.split('/');
    const filename = urlParts[urlParts.length - 1];
    
    if (filename) {
      const nameWithoutExt = filename.split('.')[0];
      return `/uploads/optimized/${nameWithoutExt}.${format}`;
    }
  }
  
  return originalSrc;
};

const webpSrc = getOptimizedImagePath(src, 'webp');
const avifSrc = getOptimizedImagePath(src, 'avif');

// Genera srcset responsive per diverse risoluzioni
const generateSrcSet = (baseSrc: string, format: string) => {
  if (!responsive) return '';
  
  const sizes = [400, 600, 800, 1200];
  return sizes.map(size => {
    const optimizedPath = getOptimizedImagePath(baseSrc, format);
    return `${optimizedPath} ${size}w`;
  }).join(', ');
};

// Debug: mostra i percorsi generati (solo in sviluppo)
if (import.meta.env.DEV) {
  console.log('üñºÔ∏è OptimizedImage Debug:');
  console.log('  Original:', src);
  console.log('  WebP:', webpSrc);
  console.log('  AVIF:', avifSrc);
}

---

<picture class={className}>
  <!-- Formato AVIF (pi√π moderno e compresso) -->
  {avifSrc && avifSrc !== src && (
    <source 
      srcset={responsive ? generateSrcSet(src, 'avif') : avifSrc}
      type="image/avif" 
      sizes={sizes}
    />
  )}
  
  <!-- Formato WebP (supporto ampio e buona compressione) -->
  {webpSrc && webpSrc !== src && (
    <source 
      srcset={responsive ? generateSrcSet(src, 'webp') : webpSrc}
      type="image/webp" 
      sizes={sizes}
    />
  )}
  
  <!-- Fallback: WebP se disponibile, altrimenti originale -->
  <img
    src={webpSrc && webpSrc !== src ? webpSrc : src}
    alt={alt}
    width={width}
    height={height}
    loading={loading}
    decoding="async"
    class="optimized-image"
    sizes={sizes}
  />
</picture>

<style>
  picture {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  .optimized-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: opacity 0.3s ease;
  }
  
  .optimized-image[loading="lazy"] {
    opacity: 0;
    animation: fadeIn 0.5s ease forwards;
  }
  
  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }
</style>
